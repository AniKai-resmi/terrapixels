<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Mini r/place</title>
<style>
body {
  margin: 0;
  background: #111;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  flex-direction: column;
}

canvas {
  background: white;
  image-rendering: pixelated;
  cursor: crosshair;
}

.palette {
  position: fixed;
  bottom: 20px;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  background: #222;
  padding: 10px;
  border-radius: 10px;
  max-width: 90%;
  justify-content: center;
}

.color {
  width: 22px;
  height: 22px;
  cursor: pointer;
  border: 2px solid #333;
}

.color:hover {
  border: 2px solid white;
}
</style>
</head>
<body>

<canvas id="board"></canvas>

<div class="palette" id="palette"></div>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

const gridSize = 200;
let pixelSize = 4;
let scale = 1;
let offsetX = 0;
let offsetY = 0;
let currentColor = "black";

canvas.width = 600;
canvas.height = 600;

const pixels = [];
for (let y = 0; y < gridSize; y++) {
  pixels[y] = [];
  for (let x = 0; x < gridSize; x++) {
    pixels[y][x] = "white";
  }
}

const colors = [
  "black","white","gray","red","orange","yellow",
  "green","lime","cyan","blue","purple","pink",
  "brown","#8B4513","#FFD700","#00FF7F","#FF1493"
];

const palette = document.getElementById("palette");

colors.forEach(color => {
  const div = document.createElement("div");
  div.className = "color";
  div.style.background = color;
  div.onclick = () => currentColor = color;
  palette.appendChild(div);
});

function draw() {
  ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
  ctx.clearRect(-offsetX/scale, -offsetY/scale, canvas.width/scale, canvas.height/scale);

  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      ctx.fillStyle = pixels[y][x];
      ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
    }
  }
}

canvas.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left - offsetX) / (pixelSize * scale));
  const y = Math.floor((e.clientY - rect.top - offsetY) / (pixelSize * scale));

  if (x >= 0 && y >= 0 && x < gridSize && y < gridSize) {
    pixels[y][x] = currentColor;
    draw();
  }
});

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoom = e.deltaY < 0 ? 1.1 : 0.9;
  scale *= zoom;
  draw();
});

let dragging = false;
let lastX, lastY;

canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});

canvas.addEventListener("mouseup", () => dragging = false);

canvas.addEventListener("mousemove", e => {
  if (!dragging) return;
  offsetX += e.clientX - lastX;
  offsetY += e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  draw();
});

draw();
</script>

</body>
</html>
